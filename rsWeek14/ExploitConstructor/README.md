# Task 1: Exploit Constructor

Learn about how parameters in a constructor work and how to inject code from there.

## The Task Intro

Create a smart contract that does not do what it looks like. That is, the constructor should load bytecode that matches the function selector, but it should do something else. Use the [walkthrough on hackerrank](https://hackernoon.com/how-to-exploit-a-solidity-constructor).

## The Solution

```apache
contract Original {
    constructor(bytes memory a) {
        /*
           The Values to return opcode can come from a complex logic
           but to keep it simple and for demo, we have hard coded them.
           It may be different in your case.
        */
        assembly {
            return(0xc0, 0x11c)
        }
    }

    function sing() public returns (string memory) {
        return "It's a Wonderful World!";
    }
}

contract Malicous {
    function sing() public returns (string memory) {
        return "Suddently the contract does not behave as I expect!";
    }
}
```

This task was at the beginning tough to understand - how is it possible to make a contract return something else then what the code you are deploying? The hackernoon article talks about Backdoor Technique or Honeypot Hack.

You can make a contract do something completly differently when you add an assembly return instruction in the constructor. This is highly malicous statement in this content, because it returns the bytecode to be deployed on the blockchain.

The deployed code to the blockchain consist out of an init bytecode and runtime bytecode, where the init bytecode is the constructor and what the constructor returns is the runtime bytecode, what is stored on the blockchain.

Solidity hides from us the return statement from the constructor, but if we return from an assembly statement a memory range, we can completely circumvent what the contract is planned to do. In the above setup it is even possible to deploy the contract with a constructor parameter, so the same contract can have different implementations.

It is not fully automated though. The first argument of `return(0xc0, 0x11c)`is the position/offset of the first argument in memory. The second parameter is the lengh. Probably this could be automated, but so far I have just gone through remix and foundry debugger to make it work manually:

- Compile the Original Contract (the return statement commented out) and debug it. Add a custom hex value like 0x89898989 as a byte parameter and see where in the memory position it is stored. This will be our first parameter.
- Compile the Malicous Contract and see how long the runtime Code is. In foundry you can do this with `vm.getDeployedCode("OriginalMalicious.sol:Malicous");`, in remix I debug the deployment, find the return statement of the constructor, check the memory range in the stack and then copy the values out of the memory.

Done üéâÔ∏è.
